## 全排列

![全排列](./images/array/全排列.png)

题解：

```c
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;

        if(nums.size()==0){
            return res;
        }

        int size=nums.size();
        int depth=0;
        vector<bool> isUsed(size,false);
        vector<int> tmpRes;

        dfs(nums,size,depth,isUsed,tmpRes,res);

        return res;
    }

    void dfs(vector<int>& nums,int size,int depth,vector<bool> isUsed,vector<int> tmpRes,vector<vector<int>>& res){
        if(depth==size){
            res.push_back(tmpRes);
        }

        for(int i=0;i<size;i++){
            if(isUsed[i]){
                continue;
            }
            isUsed[i] =true;
            tmpRes.push_back(nums[i]);
            dfs(nums,size,depth+1,isUsed,tmpRes,res);
            isUsed[i] =false;
            tmpRes.pop_back();
        }
    }
};
```

![电话号码的字母组合](./images/array/电话号码的字母组合.png)

```c++
class Solution {
public:
    string tmp;
    vector<string> res;
    vector<string> board={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};
    void DFS(int pos,string digits){
        if(pos==digits.size()){
            res.push_back(tmp);
            return;
        }
        int num=digits[pos]-'0';
        for(int i=0;i<board[num].size();i++){
            tmp.push_back(board[num][i]);
            DFS(pos+1,digits);
            tmp.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0) return res;
        DFS(0,digits);
        return res;
    }
};
```

技巧:可以采用广度优先遍历和深度优先遍历

## 盛最多水的容器

![盛最多水的容器](./images/array/盛最多水的容器.png)

采用双指针解法：每次移动短边。

```c++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int maxArea=-1;
        int size=height.size();
        int left=0;
        int right=size-1;

        while(left<right){
            if(height[left]<height[right]){
                maxArea=max(maxArea,height[left]*(right-left));
                left++;
            }
            else {
                maxArea=max(maxArea,height[right]*(right-left));
                right--;
            }
        }

        return maxArea;

    }
};
```

